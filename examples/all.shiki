use "stdlib/io"
use "stdlib/mem" (Allocator as Alloc, free)

extern c_malloc(usize) -> *u8
extern c_free(*u8)
extern c_puts(*u8)

interface Printable {
    fn print(self)
}

interface Serializable {
    fn serialize(self) -> []u8
    fn name(self) -> string
}

// plain struct
struct Point {
    x: f32,
    y: f32,

    // static method (no self)
    fn new(x: f32, y: f32) -> Point {
        return Point { x: x, y: y, };
    }

    // instance method (self = reference)
    fn print(self) {
        c_puts("point");
    }

    // mutating via self pointer
    fn scale(self, factor: f32) {
        self.x = self.x * factor;
        self.y = self.y * factor;
    }
}

// generic struct
struct Pair[A, B] {
    first:  A,
    second: B,

    fn swap(self) -> Pair[B, A] {
        return Pair[B, A] { first: self.second, second: self.first, };
    }
}

// struct with every primitive type and all type forms
struct Kitchen {
    a: i8,
    b: i16,
    c: i32,
    d: i64,
    e: u8,
    f: u16,
    g: u32,
    h: u64,
    i: f32,
    j: f64,
    k: bool,
    l: usize,
    m: string,
    n: *u8,            // pointer type
    o: []u8,           // slice type
    p: [16]u8,         // fixed array type
    q: ?i32,           // optional type
    r: Pair[i32, f32], // named generic type
}

// plain union
union Shape {
    circle:    f32,
    rectangle: Point,
    nothing,

    fn is_circle(self) -> bool {
        return match self {
            circle(r) => { true },
            _         => { false },
        };
    }
}

// generic union
union Option[T] {
    some: T,
    none,

    fn is_some(self) -> bool {
        return match self {
            some(v) => { true },
            none    => { false },
        };
    }
}

macro assert(cond: expr, msg: expr) {
    if !cond {
        c_puts(msg);
    }
}

macro log(val: expr) {
    c_puts("log");
}

fn print_it[T](val: T) where T: interface Printable {
    val.print();
}

fn print_two[T, U](a: T, b: U) where T: interface Printable, U: interface Printable + Serializable {
    a.print();
    b.print();
}

fn demo_statements(alloc: Alloc) -> i32 {

    // let_stmt: inferred
    let x = 5;

    // let_stmt: explicit type
    let y: i32 = 10;

    // let_stmt: pointer and slice types
    let p: *u8 = c_malloc(64);
    let s: []u8 = c_malloc(32);

    // defer_stmt: runs on scope exit
    defer c_free(p);
    defer {
        c_free(s);
        c_puts("freed");
    }

    // expr_stmt  assignment
    x = 42;

    // expr_stmt: compound field assignment
    let pt = Point.new(1.0, 2.0);
    pt.x = 99.0;

    // if_expr as statement (value discarded)
    if x > 0 {
        c_puts("positive");
    } else if x == 0 {
        c_puts("zero");
    } else {
        c_puts("negative");
    }

    // if_expr as value
    let sign: i32 = if x > 0 { 1 } else if x == 0 { 0 } else { -1 };

    // match_expr as statement
    let shape = Shape.circle(3.14);
    match shape {
        circle(r)    => { c_puts("circle"); },
        rectangle(p) => { c_puts("rect"); },
        nothing      => { c_puts("nothing"); },
    }

    // match_expr as value
    let label: string = match shape {
        circle(r)    => { "circle" },
        rectangle(p) => { "rect" },
        nothing      => { "nothing" },
        _            => { "unknown" },
    };

    // match on literal
    let code: i32 = 42;
    match code {
        0    => { c_puts("zero"); },
        42   => { c_puts("answer"); },
        true => { c_puts("wat"); },
        _    => { c_puts("other"); },
    }

    // loop_stmt
    let i = 0;
    loop {
        if i >= 10 { break; }
        i = i + 1;
    }

    // while_stmt
    while i > 0 {
        i = i - 1;
    }

    // for_stmt
    let arr: [8]i32 = [8]i32 {};
    for elem in arr {
        c_puts("elem");
    }

    // for over range
    for j in 0..10 {
        c_puts("j");
    }

    // labeled break: loop_stmt
    :outer loop {
        loop {
            break :outer;
        }
    }

    // labeled continue: while_stmt
    let k = 0;
    :top while k < 10 {
        k = k + 1;
        if k == 5 { continue :top; }
    }

    // labeled for
    :rows for row in arr {
        break :rows;
    }

    // comptime_stmt: let
    comptime let size = @sizeof(i32);

    // comptime_stmt: if as expr_stmt
    comptime if @typeid(i32) == @typeid(i32) {
        c_puts("same type");
    }

    // comptime_stmt: for
    comptime for field in @fields(Point) {
        c_puts(field.name);
    }

    // return_stmt
    return x;
}

fn demo_expressions() {

    // all binary operators
    let a = 1 + 2;
    let b = 10 - 3;
    let c = 4 * 5;
    let d = 20 / 4;
    let e = 7 % 3;
    let f = 1 << 3;
    let g = 16 >> 2;
    let h = 5 < 10;
    let ii = 5 > 10;
    let j = 5 <= 5;
    let k = 5 >= 6;
    let l = 1 == 1;
    let m = 1 != 2;
    let n = 0b1010 & 0b1100;
    let o = 0b1010 ^ 0b1100;
    let p = 0b1010 | 0b1100;
    let q = true && false;
    let r = true || false;

    // all unary operators
    let u1 = !true;
    let u2 = -42;
    let u3 = ~0xFF;
    let val: i32 = 5;
    let u4 = &val;   // addressof
    let u5 = *u4;    // deref

    // all literals
    let lit_int    = 42;
    let lit_neg    = -1;
    let lit_float  = 3.14;
    let lit_bool_t = true;
    let lit_bool_f = false;
    let lit_str    = "hello";
    let lit_null   = null;

    // struct_init plain
    let pt = Point { x: 1.0, y: 2.0, };

    // struct_init generic
    let pair = Pair[i32, f32] { first: 1, second: 2.0, };

    // union_init with payload
    let s = Shape.circle(3.14);

    // union_init unit variant
    let nothing = Shape.nothing;

    // optional
    let maybe = Option[i32].some(99);
    let empty  = Option[i32].none;

    // field access
    let px = pt.x;

    // method call
    pt.print();
    pt.scale(2.0);

    // static call
    let pt2 = Point.new(3.0, 4.0);

    // index access
    let arr: [4]i32 = [4]i32 {};
    let elem = arr#[0];

    // generic instantiation at call site
    let swapped = pair.swap();

    // builtin calls
    let sz     = @sizeof(i32);
    let al     = @alignof(Point);
    let tid    = @typeid(f32);
    let tname  = @typename(Point);
    let has    = @has_field(Point, "x");
    let fields = @fields(Point);
    let fx     = @field(pt, "x");

    // comptime expr inline
    let csz = comptime @sizeof(i32) * 2;

    // interface type used as parameter (fat pointer)
    let printable: interface Printable = pt;
    let combo: interface Printable + Serializable = pt;

    // nested expressions
    let complex = (a + b) * (c - d) / (e + 1);
    let bitwise = (n & 0xFF) | (o << 2) ^ (p >> 1);

    // break with value (reserved for future loop-as-expression)
    let result: i32 = loop {
        break 99;
    };
}

fn do_nothing() {
    return;
}

fn ret_i32()    -> i32    { return 0; }
fn ret_f64()    -> f64    { return 0.0; }
fn ret_bool()   -> bool   { return false; }
fn ret_string() -> string { return "hi"; }
fn ret_ptr()    -> *u8    { return null; }
fn ret_slice()  -> []u8   { return null; }
fn ret_opt()    -> ?i32   { return null; }

