fn add(a: i32, b: i32) -> i32 {
    let result: i32 = a + b;
    return result;
}

struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let x: i32 = 42;
    let y: f64 = 3.14;
    let flag: bool = true;
    let is_false: bool = false;
    
    if x > 10 {
        x = 1;
    } else if x == 10 {
        x = 2;
    } else {
        x = 3;
    }
    
    loop {
        break;
    }
    
    while x < 100 {
        x = x + 1;
        if x == 50 {
            continue;
        }
    }
    
    let ptr: *i32 = &x;
    
    let s: Point = Point {
        x: 1.5,
        y: 2.5,
    };
    
    x = 5;
    
    let logic: bool = true && false || !flag;
    let bitwise: i32 = 5 & 3 | 2 ^ 1;
    let shift: i32 = 8 << 2 >> 1;
    let comparison: bool = 10 == 20 && 5 <= 10 && 3 != 4;
}

struct Generic[T, U] {
    first: T,
    second: U,
}

fn polymorphic[T](value: T) -> T where T: interface Drawable {
    return value;
}

fn escape_test() {
    let escaped: string = "line1\nline2\ttab";
}
